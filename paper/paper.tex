\documentclass[9pt,letterpaper]{extarticle}
\usepackage{extsizes}
\usepackage[paper=letterpaper,margin=1in]{geometry}

% Table coloring: Must be imported before TikZ
\usepackage[table,x11names,dvipsnames]{xcolor}

\usepackage{xspace,amsmath,amsfonts,amssymb,hyperref,tikz,multirow}
\usepackage{graphicx}
% \graphicspath{{../data/R_plots/}}

\usepackage{parskip}

\newcommand{\todo}[1]{%
	\mbox{}% prevent marginpar from being on previous paragraph
	\marginpar{%
		\colorbox{red!80!black}{\textcolor{white}{to-do}}%
		\vspace*{-22pt}% hack!
	}%
	\textcolor{red}{#1}%
}

\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{graphicx}
\usepackage{multicol}

\title{N-dimensional Tic Tac Toe, and Adventure in Modules}
\author{Alex Grasley \and Jeff Young \and Michael McGirr}
\date{}

\begin{document}
	\maketitle
	% \begin{abstract}
  %   Do we want/need an abstract?
	% \end{abstract}

  \section{Overview of Project}
  % A high-level overview of what your project is about. This should answer the
  % following questions: What is the domain? Who are the users? What kinds of
  % things can those users do with your project?

  Our project initially began as a pokemon simulator - but early on we realized
  that we could make better use of the SML module system by approaching the
  problem of simulating player-based games in a more abstract general way.
  By doing so we could define the basic notion of what a game simulation requires
  and isolate a pattern to follow for any number of games that fit this
  model.
  A game would then be a specific implementation - in our case
  \textit{Tic-tac-toe} - that used this pattern.

  \section{Program description}
  % A list and brief description of all of the signatures, modules, and functors
  % in your project. In the description of signatures and modules, you should
  % highlight especially important types and functions. The goal of this section
  % is to guide the reader through your source code, putting things into their
  % proper context. It isn’t necessary to describe every helper function, but this
  % section should provide a reasonably complete overview of the content of your
  % project.
  
  Our project is separated between the code that describes the game simulation
  and the code that uses this to make a specific \textit{Tic-tac-toe} implementation.
  The game simulation is located in the \texttt{game.sml} file. Likewise, the
  code for the \textit{Tic-tac-toe} implementation is located in
  \texttt{tictactoe.sml} and uses modules from \texttt{matrix.sml}.

  As we touched on before - the notion of a game is generalized in the
  \texttt{game.sml} file. This defines the signatures which make up the pattern
  of a game and a functor to run a game.
  The general pattern for a game under our model consists of three purposely
  isolated pieces.
  These are \textit{State}, \textit{Actions}, and \textit{Agents} - which are
  each given their own signature in \texttt{game.sml}.
  These are then wrapped together with a functor to execute a game.
  The idea is that any game consists of a state, a set of actions on that state,
  and an agents that take actions for a state. A specific implementation of a
  game would use the relationship between these three general pieces to define
  a runnable game with its own modules.

  Our implementation of \textit{Tic-tac-toe} uses this game model to operate and
  is primarily defined within \texttt{tictactoe.sml}.
  This roughly follows the order:
  State $\rightarrow$ Action $\rightarrow$ Agent $\rightarrow$ Execution.

  In \texttt{tictactoe.sml} we have two signatures - one that extends state
  (the \texttt{STATE} signature from \texttt{game.sml}) for \textit{Tic-tac-toe}
  called \texttt{TTTSTATE} and another that does the same with action
  (the \texttt{ACTION} signature from \texttt{game.sml}) called
  \texttt{TTTACTION}.
  We don't extend the \texttt{AGENT} signature specifically for \textit{Tic-tac-toe}.

  There are many module structures instantiated in \texttt{tictactoe.sml}
  for the various kinds of state, actions and agents that we eventually want to
  use - such as \texttt{TttState} and \texttt{TttAction} for instance - but each will
  be used to implement the next kind of module.
  These module structures are bound to functors like \texttt{TttStateFn} which
  takes a module implementing a square matrix module (\texttt{SQUAREMATRIX})
  and returns a module that implements \texttt{TTTSTATE}. The functors in
  \texttt{tictactoe.sml} effectively take a module structure that implements the
  previous module of the game pattern and produce the current (or next)
  modular piece.
  
  The functor \texttt{TttActionFn} (used by modules structures like
  \texttt{TttAction} and \texttt{Ttt3DAction}) takes a module that implements
  \texttt{TTTSTATE} and gives us a module implementing \texttt{TTTACTION}.
  The functors \texttt{TttRandomAgent} and \texttt{TttHumanAgentFn} take
  modules which implement \texttt{TTTACTION} and return a module that implements
  \texttt{AGENT}.

  We can then instantiate a structure (like \texttt{TttExecRandom} for example)
  that will run a game of \textit{Tic-tac-toe}
  To do so we provide our \texttt{ExecFn} functor from
  \texttt{game.sml} with a module that implements \texttt{AGENT}.
  \texttt{ExecFn} then gives us a module that implements \texttt{EXEC}.
  
  The idea being that we instantiated specific module structures
  (like \texttt{TttState}) for different cases of states, actions and agents
  that may occur in various kinds of \textit{Tic-tac-toe} games.
  We then described functors which linked these structures to the functions
  meant for that specific use and returned a new module.
  When provided with the correct input module, these functors will give us
  modules that implement that portion of the overall game pattern.

	\section{Design Decisions}
  % (Most important!) Describe in detail 3-5 design decisions you made during your
  % project, with respect to abstraction and/or modularity. For example, what is a
  % piece of information that you chose to hide and why? How did you decide on a
  % particular way of separating your system into modules compared to another. How
  % did you reduce coupling between two modules? These design decisions should
  % emphasize how you applied ideas from the papers we’ve read (and associated
  % discussions) to the design of your project. It might be helpful here to
  % include snippets from old versions (or hypothetical alternative versions) of
  % your project to compare and contrast with the final version.
  \subsection{Creating an Abstract Game Engine}
  % How we came up with the abstract design
  \subsection{Higher Ordered Signatures, and the ``Include'' incantation}
  % Something about how previously we just had signature -> structure -> functors
  % but with include it became possible to 
  \subsection{Separation of IO, or How I learned to not fight SML in search of Purity}
  In the first implementation of our project we simulated Haskell's IO monad by
  creating a ``show'' signature, and an ``IO'' functor, as shown below:

  \begin{verbatim}
    signature SHOW =
    sig
        type a
        val show : a -> string
    end
    
    signature IO =
    sig
        structure S : SHOW
    
        val printIO : S.a -> unit
        val read : 'a -> string option
        val say : string -> unit
    end
    
    functor Io (structure Sh : SHOW) : IO =
    struct
    
      structure S = Sh
    
      (* append a new line to a str, this is expensive *)
      fun appendNewLine str = implode $ (explode str) @ [#"\n"]
    
      fun printIO x = print o appendNewLine o S.show $ x
    
      (* function to get user input, it doesn't do anything with its argument *)
      fun read _ = TextIO.inputLine TextIO.stdIn
    
      fun say str = print o appendNewLine $ str
    
    end
  \end{verbatim}
  We decided against this approach i.e. isolating IO into a separate module,
  because it began to pollute our design's dependency graph with unwanted edges.
  In haskell type class instances exist in an global overloaded name space, that
  takes advantage of haskell's dispatch system. So each data type that is
  implemented for the \texttt{Show} typeclass is able to be printed to StdOut
  \textit{without} carrying around its respective show function. This is not the
  case in SML and it was sorely missed in our implementation. If we were to
  follow the Haskell style of IO (separating impure and pure code explicitly),
  then an IO dependency would be requisite anytime we needed to perform any IO.
  Thus, the IO node would become a dominating node in our dependency graph and
  the import of it into every functor would quickly become unweidly and
  boilerplate. Hence, we chose an SML style design where the structures that are
  mapped upon carry any relevant functions with them to maintain a clean
  decomposition in our design. This type of structure bloat, although
  disgraceful to a haskell programming, seems to be encouraged by SML's module
  system.

  \subsection{You can do it in 2-dimensions, but can you do it in n-dimensions!}
  Initially, we had conceived on implementing a pokemon battle simulator. As we
  dove into the problem domain we realized that instead of falling into a
  specific, flow-chart design with modules like: Pokemon, Combat, Moves etc. it
  would be better design to create an abstract game engine and then make pokemon
  \textit{an instance of} the abstract game engine. A similar pattern occurred
  during our first implementation of the matrix library utilized by the tic tac
  toe state viz. we realized we wrote a, too specific, flowchart-y instance of a
  matrix library. Thus, in the spirit of modularity, we refactored the matrix
  library to implement an abstract \texttt{CONTAINER} signature. Then based on
  this signature, it became possible to create sub-signatures that specified the
  types of the CONTAINER signature. A good example is shown below:

  \begin{verbatim}
    signature CONTAINER = sig
    
      (* ADT of the container *)
      type 'a container
      (* type used to index the container *)
      type index
      (* type used to represent the size of the container *)
      type size
    ...
    end

    (* Matrices that are square and so only need size to be a single int *)
    signature SQUAREMATRIX = sig
    
      include CONTAINER where type size = int
    
      val intToIndex : 'a container * int -> index
    
    end

  \end{verbatim}
  In this example we show the relevant parts of the \texttt{CONTAINER} signature
  and how we used that signature to create a \textit{more specific}
  \texttt{SQUAREMATRIX} signature e.g. a matrix whose size datatype need only be
  a single integer value. This allows for a very flexible and modular
  implementation, in addition to square matrices we could create jagged matrices
  by following the same pattern viz. defining a \texttt{JAGGEDMATRIX} and
  setting size to ``int * int''.

  Not only is the second layer of abstraction useful for changing matrix
  properties on the fly, but it is also useful for changing the underlying
  implementation and dimensionality of the matrix. With this design we were able
  to create a functor that, when given a structure of type
  \texttt{SQUAREMATRIX}, and a structure of type \texttt{VECT} will return a
  matrix of whose underlying datatype is implemented by a structure, V of type
  \texttt{VECT}, that dictates the underlying datatype of the matrix, and a
  structure M, of type \texttt{SQUAREMATRIX} that specifies the datatype that
  stores the V structure. For example, we create matrices that are created with
  arrays, vectors and lists by passing each as a structure of type
  \texttt{VECT}; any such data structure is viable as long as it supports the
  \texttt{VECT} signature. By altering the structure M, of type
  \texttt{SQUAREMATRIX} we create n-dimensional matrices. So by varying both we
  gain the ability to create n-dimensional matrices, with abstracted underlying
  data types. Thus, the double abstracted design of our matrix library is a
  semantic definition of a matrix, which separates and abstracts the underlying
  datatype implementation from the dimensionality of the matrix and the
  underlying implementation details, thereby allowing for extreme reuse and
  flexibility.
  
  \subsection{The Functor is love, the Functor is life}
  % How functors enabled our clean decomposition and modular design

\end{document}
