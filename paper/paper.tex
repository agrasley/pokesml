\documentclass[9pt,letterpaper]{extarticle}
\usepackage{extsizes}
\usepackage[paper=letterpaper,margin=1in]{geometry}

% Table coloring: Must be imported before TikZ
\usepackage[table,x11names,dvipsnames]{xcolor}

\usepackage{xspace,amsmath,amsfonts,amssymb,hyperref,tikz,multirow}
\usepackage{graphicx}
% \graphicspath{{../data/R_plots/}}

\usepackage{parskip}

\newcommand{\todo}[1]{%
	\mbox{}% prevent marginpar from being on previous paragraph
	\marginpar{%
		\colorbox{red!80!black}{\textcolor{white}{to-do}}%
		\vspace*{-22pt}% hack!
	}%
	\textcolor{red}{#1}%
}

\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{graphicx}
\usepackage{multicol}

\title{N-dimensional Tic Tac Toe, and Adventure in Modules}
\author{Alex Grasley \and Jeff Young \and Michael McGirr}
\date{}

\begin{document}
	\maketitle
	% \begin{abstract}
  %   Do we want/need an abstract?
	% \end{abstract}

  \section{Overview of Project}
  % A high-level overview of what your project is about. This should answer the
  % following questions: What is the domain? Who are the users? What kinds of
  % things can those users do with your project?

  Our project initially began as a pokemon simulator - but early on we realized
  that we could make better use of the SML module system by approaching the
  problem of simulating player-based games in a more abstract general way.
  By doing so we could define the basic notion of what a game simulation requires
  and isolate a pattern to follow for any number of games that fit this
  model.
  A game would then be a specific implementation - in our case
  \textit{Tic-tac-toe} - that used this pattern.

  \section{Program description}
  % A list and brief description of all of the signatures, modules, and functors
  % in your project. In the description of signatures and modules, you should
  % highlight especially important types and functions. The goal of this section
  % is to guide the reader through your source code, putting things into their
  % proper context. It isn’t necessary to describe every helper function, but this
  % section should provide a reasonably complete overview of the content of your
  % project.
  
  Our project is separated between the code that describes the game simulation
  and the code that uses this to make a specific \textit{Tic-tac-toe} implementation.
  The game simulation is located in the \texttt{game.sml} file. Likewise, the
  code for the \textit{Tic-tac-toe} implementation is located in
  \texttt{tictactoe.sml} and uses modules from \texttt{matrix.sml}.

  As we touched on before, the notion of a game is generalized in the
  \texttt{game.sml} file. This defines the signatures which make up the pattern
  of a game and a functor to run a game.
  The general pattern for a game under our model consists of three purposely
  isolated pieces.
  These are \textit{State}, \textit{Actions}, and \textit{Agents} - which are
  each given their own signature in \texttt{game.sml}.
  These are then wrapped together with a functor to execute a game.
  The idea is that any game consists of a state, a set of actions on that state,
  and agents that select which action to perform on a given state. A specific implementation of a
  game would use the relationship between these three general pieces to define
  a runnable game with its own modules.

  Our implementation of \textit{Tic-tac-toe} uses this game model to operate and
  is primarily defined within \texttt{tictactoe.sml}.
  This roughly follows the order:
  State $\rightarrow$ Action $\rightarrow$ Agent $\rightarrow$ Execution.

  In \texttt{tictactoe.sml} we have two signatures: one that extends state
  (the \texttt{STATE} signature from \texttt{game.sml}) for \textit{Tic-tac-toe}
  called \texttt{TTTSTATE} and another that does the same with action
  (the \texttt{ACTION} signature from \texttt{game.sml}) called
  \texttt{TTTACTION}.
  We don't extend the \texttt{AGENT} signature specifically for \textit{Tic-tac-toe}.
  These extended signatures are perfectly compatible with the original signatures
  due to the structural matching of SML signatures. 

  There are many module structures instantiated in \texttt{tictactoe.sml}
  for the various kinds of state, actions and agents that we eventually want to
  use---such as \texttt{TttState} and \texttt{TttAction} for instance---but each will
  be used to implement the next kind of module.
  These module structures are bound to functors like \texttt{TttStateFn} which
  takes a module implementing a square matrix module (\texttt{SQUAREMATRIX})
  and returns a module that implements \texttt{TTTSTATE}. The functors in
  \texttt{tictactoe.sml} effectively take a module structure that implements the
  previous module of the game pattern and produce the current (or next)
  modular piece.
  
  The functor \texttt{TttActionFn} (used by module structures like
  \texttt{TttAction} and \texttt{Ttt3DAction}) takes a module that implements
  \texttt{TTTSTATE} and gives us a module implementing \texttt{TTTACTION}.
  The functors \texttt{TttRandomAgentFn} and \texttt{TttHumanAgentFn} take
  modules which implement \texttt{TTTACTION} and return a module that implements
  \texttt{AGENT}.

  We can then instantiate a structure (like \texttt{TttExecRandom} for example)
  that will run a game of \textit{Tic-tac-toe}.
  To do so we provide our \texttt{ExecFn} functor from
  \texttt{game.sml} with a module that implements \texttt{AGENT}.
  \texttt{ExecFn} then gives us a module that implements \texttt{EXEC}.
  
  The idea being that we instantiated specific module structures
  (like \texttt{TttState}) for different cases of states, actions and agents
  that may occur in various kinds of \textit{Tic-tac-toe} games.
  We then described functors which linked these structures to the functions
  meant for that specific use and returned a new module.
  When provided with the correct input module, these functors will give us
  modules that implement that portion of the overall game pattern.

	\section{Design Decisions}
  % (Most important!) Describe in detail 3-5 design decisions you made during your
  % project, with respect to abstraction and/or modularity. For example, what is a
  % piece of information that you chose to hide and why? How did you decide on a
  % particular way of separating your system into modules compared to another. How
  % did you reduce coupling between two modules? These design decisions should
  % emphasize how you applied ideas from the papers we’ve read (and associated
  % discussions) to the design of your project. It might be helpful here to
  % include snippets from old versions (or hypothetical alternative versions) of
  % your project to compare and contrast with the final version.

  \subsection{Creating an Abstract Game Engine}
  % How we came up with the abstract design
  The design for our game engine stemmed from trying to isolate the common
  general components of what would be required to create a running game.
  Rather than focus on creating one specific game implementation where these
  problems are addressed in an \textit{ad hoc} way, we wanted to
  look at the larger picture and view the problem in terms of the common pattern
  that emerged between these kinds of games.
  
  Each of the portions of the \textit{State}-\textit{Actions}-\textit{Agents}
  design is independent so that - once created - it does not rely on other
  modules for its internal pieces.
  Each of the constituent parts of the game engine is more akin to a node on a
  graph and the interfaces are like edges.
  The pieces should be thought of as islands of code that could then interact
  with other modules. By using the game model to define a specific game - we
  essentially create more specific versions of those islands following the
  recipe spelled out in the signatures.

\subsection{Exploiting Structural Typing}
  % Something about how previously we just had signature -> structure -> functors
  % but with include it became possible to
  One major element of SML's module system that we were about to exploit in our project was
  the structural matching of modules to signatures. Coupled with liberal use of the \texttt{include}
  keyword, this allowed us to easily extend signature definitions in a way reminiscent of inheritance
  and subclassing in OOP.
  
  This design decision is most apparent in our extension of the abstract game engine to
  our chosen implementation domain of \textit{Tic-tac-toe}. Our more abstract interfaces defined
  in \texttt{game.sml} were often insufficient for describing the full interface
  needed for our concrete implementation. For example, \textit{Tic-tac-toe} state modules
  needed to export a \texttt{cell} datatype that represented the actual Xs and Os placed on the game
  board. Including this datatype in the abstract \texttt{STATE} signature in \texttt{game.sml}
  would be inappropriate, as any game outside of \textit{Tic-tac-toe} has no need for the
  \texttt{cell} datatype. Instead, we created a new signature \texttt{TTTSTATE} that extended
  the \texttt{STATE} signature via the \texttt{include} keyword with additional interface elements.
  Additionally, this extension refined
  some of the abstract types in \texttt{STATE} using the \texttt{where} keyword in order to give them
  concrete type definitions. For example, the abstract type \texttt{state} is defined to always be
  equivalent to the type \texttt{cell * (cell Matrix.container)} in a module implementing \texttt{TTTSTATE}.
  
  We were able to exploit this refined state signature to narrow the domain of the \texttt{TttActionFn}
  functor to only states appropriate for \textit{Tic-tac-toe}, rather than any abstract game state.
  However, thanks to the structural matching properties of the SML module system, we can still
  use a module implementing \texttt{TTTSTATE} wherever we would use a module implementing
  \texttt{STATE}. In fact, because the matching is structural and not nominal, we get this property
  for free, with no need to specify the relationship by name in the code. This allows us to still use
  signatures and functors in our implementation that depend only on the more abstract 
  definitions like the \texttt{AGENT} signature
  or the \texttt{ExecFn} functor, which are only defined for the more abstract game engine. 
  
  \subsection{Separation of IO, or How I learned to not fight SML in search of Purity}
  In the first implementation of our project we simulated Haskell's IO monad by
  creating a ``show'' signature, and an ``IO'' functor, as shown below:

  \begin{verbatim}
    signature SHOW =
    sig
        type a
        val show : a -> string
    end
    
    signature IO =
    sig
        structure S : SHOW
    
        val printIO : S.a -> unit
        val read : 'a -> string option
        val say : string -> unit
    end
    
    functor Io (structure Sh : SHOW) : IO =
    struct
    
      structure S = Sh
    
      (* append a new line to a str, this is expensive *)
      fun appendNewLine str = implode $ (explode str) @ [#"\n"]
    
      fun printIO x = print o appendNewLine o S.show $ x
    
      (* function to get user input, it doesn't do anything with its argument *)
      fun read _ = TextIO.inputLine TextIO.stdIn
    
      fun say str = print o appendNewLine $ str
    
    end
  \end{verbatim}
  We decided against this approach i.e. isolating IO into a separate module,
  because it began to pollute our design's dependency graph with unwanted edges.
  In haskell, type class instances exist in an global overloaded name space,
  that takes advantage of haskell's dispatch system. So each data type that is
  implemented for the \texttt{Show} typeclass is able to be printed to StdOut
  \textit{without} carrying around its respective show function. This is not the
  case in SML, and it was sorely missed in our implementation. If we were to
  follow the Haskell style of IO (separating impure and pure code explicitly),
  then an IO dependency would be requisite anytime we needed to perform any IO.
  Thus, the IO node would become a dominating node in our dependency graph, and
  the its import into every functor would quickly become boilerplate and
  unweidly. Hence, we chose an SML style design, where the structures that are
  mapped upon carry any relevant functions with them, which maintains a clean
  decomposition in SML. This type of structure bloat, although disgraceful to a
  haskell programming, seems to be encouraged by SML's module system.

  \subsection{You can do it in 2-dimensions, but can you do it in n-dimensions!}
  Our initial intent was to implement a pokemon battle simulator. As we
  dove into the problem domain we realized that instead of falling into a
  specific, flow-chart design with modules like: Pokemon, Combat, Moves etc. it
  would be better design to create an abstract game engine and then make pokemon
  \textit{an instance of} the abstract game engine. A similar pattern occurred
  during our first implementation of the matrix library utilized by the tic tac
  toe state. We wrote a single matrix module with more rigidly defined 
  dimensions and underlying implementation details. While it was abstract, it was not very modular,
  as it required writing a new module from the ground up if any of the 
  implementation details were to be changed. Thus, in the spirit of modularity, we refactored the matrix
  library to implement an abstract \texttt{CONTAINER} signature. Then based on
  this signature, it became possible to create sub-signatures that specified the
  types of the CONTAINER signature. A good example is shown below:

  \begin{verbatim}
    signature CONTAINER = sig
    
      (* ADT of the container *)
      type 'a container
      (* type used to index the container *)
      type index
      (* type used to represent the size of the container *)
      type size
    ...
    end

    (* Matrices that are square and so only need size to be a single int *)
    signature SQUAREMATRIX = sig
    
      include CONTAINER where type size = int
    
      val intToIndex : 'a container * int -> index
    
    end

  \end{verbatim}
  In this example we show the relevant parts of the \texttt{CONTAINER} signature
  and how we used that signature to create a \textit{more specific}
  \texttt{SQUAREMATRIX} signature e.g. a matrix whose size datatype need only be
  a single integer value. This allows for a very flexible and modular
  implementation, in addition to square matrices we could create jagged two-dimensional matrices
  by following the same pattern viz. defining a \texttt{JAGGEDMATRIX} and
  setting size to ``int * int''.

  Not only is the second layer of abstraction useful for changing matrix
  properties on the fly, but it is also useful for changing the underlying
  implementation and dimensionality of the matrix. With this design we were able
  to create a functor that, when given a structure of type
  \texttt{SQUAREMATRIX}, and a structure of type \texttt{VECT} will return a
  matrix of whose underlying datatype is implemented by a structure, V of type
  \texttt{VECT}, that dictates the underlying datatype of the matrix, and a
  structure M, of type \texttt{SQUAREMATRIX} that specifies the datatype that
  stores the V structure. For example, we create matrices that are created with
  arrays, vectors and lists by passing each as a structure of type
  \texttt{VECT}; any such data structure is viable as long as it supports the
  \texttt{VECT} signature. By altering the structure M, of type
  \texttt{SQUAREMATRIX} we create n-dimensional matrices. So by varying both we
  gain the ability to create n-dimensional matrices, with abstracted underlying
  data types. Thus, the double abstracted design of our matrix library is a
  semantic definition of a matrix, which separates and abstracts the underlying
  datatype implementation from the dimensionality of the matrix and the
  underlying implementation details, thereby allowing for extreme reuse and
  flexibility.
  
  \subsection{The Functor is love, the Functor is life}
  % How functors enabled our clean decomposition and modular design

\end{document}
